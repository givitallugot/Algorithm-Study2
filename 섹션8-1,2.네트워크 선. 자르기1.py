# Bottom-Up 방식, 아주 작은 문제의 해를 구하고 이를 이용해서 점점 더 큰 문제의 해를 구하는 방식

# dy에 1 - 7까지 index, 네트워크 선의 길이

# 1m 네트워크 선을 1m나 2m로 자를 수 있는 방법의 수 => 1개 (직관적, 초기화)

# 2m 네트워크 선을 1m나 2m로 자를 수 있는 방법의 수 => 2개 (직관적, 초기화)

# 3m 네트워크 선을 1m나 2m로 자를 수 있는 방법의 수? (점화식 이용)
# - 오른쪽 맨 마지막 토막이 1m => 앞에 2m인데, 2m 네트워크 선 자르는 방법은 2개
# - 오른쪽 맨 마지막 토막이 2m => 앞에 1m인데, 1m 네트워크 선 자르는 방법은 1개
# => 총 3개

# 4m 네트워크 선을 1m나 2m로 자를 수 있는 방법의 수? (점화식 이용)
# - 오른쪽 맨 마지막 토막이 1m => 앞에 3m인데, 3m 네트워크 선 자르는 방법은 3개
# - 오른쪽 맨 마지막 토막이 2m => 앞에 2m인데, 2m 네트워크 선 자르는 방법은 2개
# => 총 5개

# 점화식, n이 주어졌을 때 f: 자를 수 있는 개수 f(n) = f(n-2) + f(n-1)

import sys
sys.stdin = open('/Users/clue7/Desktop/코테스터디2/섹션 8/1, 2. 네트워크 선 자르기/in5.txt')
n = int(input())
dy = [0]*(n+1)
dy[1] = 1
dy[2] = 2
for i in range(3, n+1):
    dy[i] = dy[i-1] + dy[i-2]

print(dy[n])